#! /bin/bash
MYNAME=$(basename $0)
MYDIR=$(dirname $0)
MYDIR=$(readlink -m "$MYDIR")
VERSION="0.0.5"
VERBOSE=""
LOGFILE=""
CONTAINER=""
SERVER=""
SSH="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet"
STOP_OPTION=""
GZIP_OPTION=""

if [ -f "$MYDIR/utilityfunctions.sh" ]; then
    source $MYDIR/utilityfunctions.sh
else
    echo "File '$MYDIR/utilityfunctions.sh' was not found." >&2
    exit 5
fi

#
# Prints the software version and exits.
#
function printVersionAndExit()
{
    echo "$MYNAME Version $VERSION on $(hostname)." >&2
}

function printHelpAndExit()
{
cat <<EOF
Usage:
  $MYNAME [OPTION]... CONTAINER_NAME

  $MYNAME - Creates archives of containers.

  -h, --help             Print this help and exit.
  -v, --version          Print version information and exit.
  --verbose              Print more messages.
  --log-file=FILE        Store all the messages in the given file too.
  --server=SERVER        Create the container on remote server.
  --stop                 Stop containers that are running.
  --gzip                 Compress the archive with gzip.

  --auto                 Execute automatic archiving of a given server.

EXAMPLES:
  pip-container-archive --server=core1 --gzip --verbose "www"
  pip-container-archive --auto --server=core1 --verbose

EOF
    exit 0
}

ARGS=$(\
    getopt \
        -o hvs:c:l \
        -l "help,verbose,version,log-file:,server:,stop,\
auto,gzip" \
        -- "$@")

if [ $? -ne 0 ]; then
    exit 6
fi

eval set -- "$ARGS"
while true; do
    case "$1" in
        -h|--help)
            shift
            printHelpAndExit
            ;;

        --verbose)
            shift
            VERBOSE="true"
            VERBOSE_OPTION="--verbose"
            ;;

        -v|--version)
            shift
            VERSION_OPTION="--version"
            ;;

        --log-file)
            shift
            LOGFILE="$(readlink -m "$1")"
            shift
            ;;

        --server)
            shift
            SERVER="$1"
            shift
            ;;

        --stop)
            shift
            STOP_OPTION="--stop"
            ;;

        --auto)
            shift
            AUTO_OPTION="true"
            ;;

        --gzip)
            shift
            GZIP_OPTION="--gzip"
            ;;

        --)
            shift
            break
            ;;

        *)
            printError "Option '$1' not handled."
            break
            ;;
    esac
done

CONTAINER="$1"

#
# Checking the command line options.
#
if [ -z "$CONTAINER" -a -z "$VERSION_OPTION" -a -z "$AUTO_OPTION" ]; then
    printError "The first argument should be the name of the container."
    exit 6
fi

#
# Checking command line arguments.
#
EXTRA_OPTIONS=$*

#
# Checking root privileges.
#
if [ -z "$SERVER" ]; then
    if [ "$EUID" -ne 0 ]; then 
        printError "This script has to have root privileges."
        exit 5
    fi
fi

function archive_file_name()
{
    local container="$1"
    local tar_file_name="${container}-container-archive.tar"

    if [ "$GZIP_OPTION" ]; then
        tar_file_name+=".gz"
    fi

    echo "$tar_file_name"
}

function get_container_names()
{
    local pattern="$1"
    local container
    local n_containers=0

    cd /var/lib/lxc 
   
    for container in $pattern; do 
        if [ ! -d "$container" ]; then
            continue
        fi

        echo "$container"
        let n_containers+=1
    done

    printVerbose "Found $n_containers container(s)."
    return 0
}

function archive_one_container()
{
    local container="$1"
    local tar_file_name
    local old_tar_file_name
    local state
    local stopped

    #
    # If the container is running and we are allowed to stop it we stop it.
    #
    state="$(lxc-ls -f | tail -n +2 | grep "^$container " | awk '{print $2}')"
    if [ "$state" == "RUNNING" ]; then
        if [ -z "$STOP_OPTION" ]; then
            printWarning "Container '$container' is running (no --stop option)."
            printWarning "Archiving on the fly."
        else
            printVerbose "Stopping container '$container'."
            lxc-stop -n "$container"
            stopped=$?
        fi
    fi
        
    #
    # Archiving into the /var/lib/lxc/ directory.
    #
    cd /var/lib/lxc

    printVerbose "Archiving container '$container'."
    tar_file_name="$(archive_file_name "$container")"
    tar_basename="$(basename $tar_file_name)"

    old_tar_file_name="${tar_file_name}.BAK"

    if [ -f "$tar_file_name" ]; then
        printVerbose "Renaming old archive file."
        mv "$tar_file_name" "$old_tar_file_name"
    fi
    
    if [ -f "$tar_file_name" ]; then
        printError "Failed to move '$tar_file_name' aside."
        return 1
    fi

    printVerbose "Archiving into '$tar_file_name'."
    if [ "$GZIP_OPTION" ]; then
        tar --numeric-owner -czf "$tar_file_name" "$container"
    else
        tar --numeric-owner -cf "$tar_file_name" "$container"
    fi

    #
    # If we stopped the container, we start it again.
    #
    if [ "$stopped" ]; then
        printVerbose "Starting container '$container'."
        lxc-start -n "$container"
    fi

    printVerbose "Done archiving '$container'..."
    return 0
}

function check_one_container()
{
    local container="$1"
    local state
    local retval=0

    state="$(lxc-ls -f | tail -n +2 | grep "^$container " | awk '{print $2}')"

    if [ "$state" == "RUNNING" ]; then
        if [ -z "$STOP_OPTION" ]; then
            retval=0
        fi
    elif [ "$state" == "STOPPED" ]; then
        printVerbose "Container '$container' is not running."
    else
        printError "Container '$container' has unknown ($state) state."
        retval=1
    fi

    return $retval
}

function archive_all_containers()
{
    local pattern="$1"
    local container
    local retval=0
    local containers="$(get_container_names $pattern)"

    for container in $containers; do
        if ! check_one_container "$container"; then
            retval=1
        fi
    done

    if [ $retval -ne 0 ]; then
        return $retval
    fi

    for container in $containers; do
        if ! archive_one_container "$container"; then
            retval=1
        fi
    done

    return $retval
}

#
# This is kinda normal operation...
#   pip-container-archive --server=core1 --gzip --verbose "www"
#
function create_archive_normal()
{
    #
    # We received the --server option and so we run the script on a remote
    # server.
    #
    printVerbose "Executing on server '$SERVER'."
    $SSH $SERVER -- \
        sudo $MYNAME \
            $GZIP_OPTION \
            $VERSION_OPTION \
            $VERBOSE_OPTION \
            $STOP_OPTION \
            "$EXTRA_OPTIONS"

    if [ -n "$SERVER" -a -z "$VERSION_OPTION" ]; then
        for container in $EXTRA_OPTIONS; do
            tar_file_name="$(archive_file_name "$container")"
            tar_basename="$(basename "$tar_file_name")"

            printVerbose "Downloading $tar_file_name"
            printVerbose "  to $tar_basename"
            $SSH $SERVER -- \
                "sudo cat $tar_file_name" >$tar_basename
        done
    fi
}

function create_backup_dir()
{
    local server=$1
    local n=5
    local nplusone=6

    if [ -z "$server" ]; then
        printError "create_backup_dir(): Expected server name."
        exit 1
    fi

    if [ -d "${server}.${nplusone}" ]; then
        rm -rf "${server}.${nplusone}"
    fi

    while true; do
        if [ $n -eq 0 ]; then
            break
        fi

        if [ -d "${server}.${n}" ]; then
            mv "${server}.${n}" "${server}.${nplusone}"
        fi

        let nplusone-=1
        let n-=1
    done

    if [ -d "$server" ]; then
        mv "${server}" "${server}.1"
    fi

    mkdir "$server"
}

function create_archive_auto_server()
{
    local server="$1"
    local target_dir
    local containers
    local container
    local n_containers

    printVerbose "Executing in auto mode..."
    if [ -z "$server" ]; then
        printError "create_archive_auto_server(): Expected server name."
        exit 1
    fi

    # Finding the target directory.
    target_dir="$HOME/archives"
    if [ ! -d "$target_dir" ]; then
        printError "Directory '$target_dir' is not found..."
        return 1
    fi

    # Entering the target directory.
    printVerbose "Entering directory '$target_dir'..."
    pushd "$target_dir" 2>/dev/null >/dev/null
    if [ $? -ne 0 ]; then
        printVerbose "Failed to enter directory '$target_directory'."
        return 1
    fi

    containers=$(pip-server-control --list --print-containers "$server")
    n_containers=0
    for container in $containers; do
        let n_containers+=1
    done

    if [ $n_containers -gt 0 ]; then
        printVerbose "Will archive $n_containers container(s)..."
    else
        printError "No containers in the server's config file."
        return 1
    fi

    create_backup_dir "$server"
    
    printVerbose "Entering directory '$target_dir'..."
    pushd "$server" 2>/dev/null >/dev/null
    if [ $? -ne 0 ]; then
        printVerbose "Failed to enter directory '$server'."
        return 1
    fi

    for container in $containers; do
        printVerbose "Archiving $container in $PWD"
        pip-container-archive --server=$server --gzip --verbose "$container"
    done

    popd 2>/dev/null >/dev/null
    popd 2>/dev/null >/dev/null
}

function create_archive_auto()
{
    local server

    for server in $(echo $SERVER | tr ',' ' '); do
        create_archive_auto_server "$server"
    done
}

#
# Doing the job.
#
if [ "$VERSION_OPTION" ]; then
    printVersionAndExit
    exit 0
elif [ -z "$SERVER" ]; then
    archive_all_containers "$EXTRA_OPTIONS"
elif [ -n "$AUTO_OPTION" ]; then
    create_archive_auto
else
    create_archive_normal
fi

