#! /bin/bash
MYNAME=$(basename "$0")
MYDIR=$(dirname "$0")
MYDIR=$(readlink -m "$MYDIR")
VERSION="0.0.7"
VERBOSE=""
LOGFILE="$HOME/pip-cmon-test.log"
EXITCODE=0

COMMAND_LINE_OPTIONS="$0 $*"
OPTION_MAIL_LIST=""
OPTION_NO_MAIL=""
OPTION_TESTS=""

OPTION_OUTPUT_DIR="/home/pipas/Desktop/stuff/work/clustercontrol-enterprise/"
OPTION_OUTPUT_DIR+="tests/s9s_test"

MAIL_LIST_FILE=""

REPORT_FILE=""

today=$(date "+%Y-%m-%d" 2>/dev/null)
YESTERDAY=$(date "+%Y-%m-%d" -d "yesterday" 2>/dev/null)

ymd=$(echo "$today" | tr '-' '_')
gzfile="${ymd}.tar.gz"

N_TESTS_PASSED=0
N_TESTS_FAILED=0
N_MAILS_SENT=0

REPORT_FILE="${ymd}.text"
OPTION_NO_HTML=""

source $MYDIR/utilityfunctions.sh

function printHelpAndExit()
{
cat <<EOF

Usage:
  $MYNAME [OPTION]... [TEST_NAME]...

  $MYNAME - Downloads test results from my server. :)

  -h, --help              Print this help and exit.
  -v, --version           Print version information and exit.
  --verbose               Print more messages.
  --log-file=FILE         Store all the messages in the given file too.

  --mail-list=NAME        The name of the mail list.
  --no-mail               Do not send mail.
 
  --no-html               Do not include html test report.

EXAMPLES:
  PASSWORD="SSSSSSS" pip-download --verbose --no-mail
  PASSWORD="SSSSSSS" pip-download --verbose --mail-list=myself

EOF

  exit 0
}

ARGS=$(\
    getopt \
        -o hvj: \
        -l "help,verbose,version,log-file:,
no-mail,no-html,mail-list:" \
        -- "$@")

if [ $? -ne 0 ]; then
    exit 6
fi

eval set -- "$ARGS"
while true; do
    case "$1" in
        -h|--help)
            shift
            printHelpAndExit
            ;;

        --verbose)
            shift
            VERBOSE="true"
            ;;

        -v|--version)
            shift
            printVersionAndExit
            ;;

        --log-file)
            shift
            LOGFILE=$(readlink -m "$1")
            shift
            ;;

        --mail-list)
            OPTION_MAIL_LIST="$2"
            shift 2
            ;;

        --no-mail)
            OPTION_NO_MAIL="true"
            shift
            ;;

        --no-html)
            OPTION_NO_HTML="true"
            shift
            ;;

        --)
            shift
            break
            ;;

        *)
            printError "Unhandled option $1"
            exit 1
            ;;
    esac
done

OPTION_TESTS="$*"


function print_header()
{
    cat <<EOF
                       TEST_NAME STATUS     COMMITTED                 ELAPSED  GIT HASH
=======================================================================================================================
EOF
}

function print_footer()
{
    cat <<EOF
=======================================================================================================================

Summary:
     passed: $N_TESTS_PASSED test(s)
     failed: $N_TESTS_FAILED test(s)

EOF
}

function download_html_file()
{
    local url
    local server="www"

    [ ! -d "$ymd" ] && mkdir "$ymd"

    test_name="$1"
    html_file="$ymd/$(basename $test_name .sh).html"

    url="https://$server/ft_install/"
    url+="?page=test&test_name=$test_name&full_screen=true"

    #
    # We download the test results from the web, this way the reports are nicely
    # formatted for easy use.
    #
    wget \
        --user=$WWW_USER \
        --password="$WWW_PASSWORD" \
        --no-check-certificate \
        "$url" \
        --output-document=$html_file 2>/dev/null

    if [ $? -ne 0 ]; then 
        printError "Failed to download $url..."
        return 1
    fi

    echo "$html_file"
}

function cut_test_case_html()
{
    local html_file
    local output_file
    local test_name

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file="$2"
                shift 2
                ;;

            --output-file)
                output_file="$2"
                shift 2
                ;;

            --test-name)
                test_name="$2"
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    [ -z "$html_file" ] && return 1
    [ -z "$output_file" ] && return 1
    [ -z "$test_name" ] && return 1

    awk_command="/p42dc 200 $test_name/,/p42dc 201 $test_name/"
    awk "$awk_command" "$html_file" >"$output_file"
}

function get_test_names_html()
{
    local html_file
    local oldifs

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file=$2
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    [ -z "$html_file" ] && return 1
    [ ! -f "$html_file" ] && return 1
    
    oldifs="$IFS"
    IFS=$'\n'
    for caseline in $(cat "$html_file" | grep "p42dc 200 "); do
        my_name=$(echo "$caseline" | awk -F' ' '{print $3}')
        printf "$my_name\n"
    done
    IFS="$oldifs"
}

function get_test_case_time()
{
    local html_file
    local oldifs

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file="$2"
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done
        
    my_time=$(cat "$html_file" | \
            grep "p42dc 300 " | \
            awk -F' ' '{print $4}')

    echo "$my_time"
}

function get_test_case_title()
{
    local html_file
    local my_title

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file="$2"
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done
        
    my_title=$(cat "$html_file" | \
        grep '^<h3>' | head -n 1 | \
        sed -e 's#<h3>##g' -e 's#</h3>##g')

    echo "$my_title"
}


function emit_test_failures()
{
    local html_file
    local oldifs

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file="$2"
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    oldifs="$IFS"
    IFS=$'\n'
    for caseline in $(cat "$html_file" | grep "p42err"); do
        error_message=$(\
            echo "$caseline" | \
                sed -e 's/p42err //g' \
                    -e 's/&/\&amp;/g' \
                    -e 's/</\&lt;/g' \
                    -e 's/>/\&gt;/g')

        if [ -z "$error_message" ]; then
            continue
        fi

        printf "        <failure message=\"$error_message\"></failure>\n"
    done
    IFS="$oldifs"

}

function emit_test_output()
{
    local html_file
    local oldifs

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file="$2"
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    if [ -z "$OPTION_NO_HTML" ]; then
        echo "        <system-out>"
        cat "$html_file" | \
            grep -v "p42dc" | \
            sed \
                -e 's/&/\&amp;/g' \
                -e 's/</\&lt;/g' \
                -e 's/>/\&gt;/g' 

        echo "        </system-out>"
    else
        echo "        <system-out></system-out>"
    fi

    echo "        <system-err></system-err>"
}

function emit_test_case_xml()
{
    local html_file
    local oldifs
    local test_name
    local test_time
    local test_title
    local test_suite
    local report_file

    while [ -n "$1" ]; do
        case "$1" in 
            --report-file)
                report_file="$2"
                shift 2
                ;;

            --html-file)
                html_file="$2"
                shift 2
                ;;

            --test-name)
                test_name="$2"
                shift 2
                ;;

            --test-suite)
                test_suite="$2"
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    test_time=$(get_test_case_time --html-file "$html_file")
    test_title=$(get_test_case_title --html-file "$html_file")
    class_name="s9s.$test_suite"

    if [ -z "$test_title" ]; then
        printWarning "No title for $test_name in $test_suite."
        printWarning "Original report file is $report_file"
        test_title="Untitled Test"
    fi
    
    if [ -z "$test_time" ]; then
        printWarning "No time for $test_name in $test_suite."
        printWarning "Original report file is $report_file"
        test_time=0
    fi

    #
    # Emitting the test case.
    #
    cat <<EOF

    <!-- 
         slice_file: $html_file 
          test_name: $test_name
    -->
    <testcase 
            classname="$class_name" 
            name="$test_title"
            time="$test_time">
EOF
    emit_test_failures --html-file "$html_file"
    emit_test_output --html-file "$html_file"
    cat <<EOF
    </testcase>
EOF
}

function process_html_file_xml()
{
    local test_name
    local html_file
    local git_date
    local git_time
    local git_timezone
    local elapsed
    local html_file

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file=$2
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    if [ -z "$html_file" ]; then
        printError "process_html_file: No HTML file."
        return 1
    elif [ ! -f "$html_file" ]; then
        printError "process_html_file: File '$html_file' was not found."
        return 1
    fi

    #
    # The downloaded file has these fields embedded in a HTML comment so that we
    # can have everything in one single HTML file.
    #
    git_date=$(cat $html_file | grep "^p42di 120" | awk '{print $3}')
    git_time=$(cat $html_file | grep "^p42di 121" | awk '{print $3}')
    gittimezone=$(cat $html_file | grep "^p42di 122" | awk '{print $3}')
    git_hash=$(cat $html_file | grep "^p42di 130" | awk '{print $3}')
    elapsed=$(cat $html_file | grep "^p42di 140" | awk '{print $3}')
    status=$(cat $html_file | grep "^p42di 110" | awk '{print $3}')
    
    test_name=$(basename "$html_file" .html)

    n_failures=$(cat $html_file | grep 'p42dc 102' | wc -l)
    n_cases=$(cat $html_file | grep 'p42dc 10' | wc -l)

    if [ "$n_cases" -eq 0 ]; then
        printWarning "No test cases in $test_name..."
    fi

    cat <<EOF
<?xml version="1.0" ?>
<!-- 
  Created by pip-download $VERSION. 
      html_file: $PWD/$html_file
      test_name: $test_name
       git_date: $git_date
       git_time: $git_time
    gittimezone: $gittimezone
       git_hash: $git_hash
        elapsed: $elapsed
         status: $status
-->
<testsuite failures="$n_failures" tests="$n_cases">
EOF
    slice_file="/tmp/pip_download.html"

    test_case_names=$(get_test_names_html --html-file "$html_file")
    for test_case_name in $test_case_names; do
        cut_test_case_html \
            --html-file "$html_file" \
            --output-file "$slice_file" \
            --test-name "$test_case_name"
        
        if [ $? -ne 0 ]; then
            return 1
        fi

        #vim "$slice_file"
        emit_test_case_xml \
            --report-file "$PWD/$html_file" \
            --html-file   "$slice_file" \
            --test-name   "$test_case_name" \
            --test-suite  "$test_name" 

        if [ $? -ne 0 ]; then
            return 1
        fi
    done

cat <<EOF
</testsuite>
EOF
    return 0
}

function process_html_file()
{
    local test_name
    local html_file
    local git_date
    local git_time
    local git_timezone
    local elapsed
    local html_file

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file=$2
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    if [ -z "$html_file" ]; then
        printError "process_html_file: No HTML file."
        return 1
    elif [ ! -f "$html_file" ]; then
        printError "process_html_file: File '$html_file' was not found."
        return 1
    fi

    #
    # The downloaded file has these fields embedded in a HTML comment so that we
    # can have everything in one single HTML file.
    #
    git_date=$(cat $html_file | grep "^p42di 120" | awk '{print $3}')
    git_time=$(cat $html_file | grep "^p42di 121" | awk '{print $3}')
    gittimezone=$(cat $html_file | grep "^p42di 122" | awk '{print $3}')
    git_hash=$(cat $html_file | grep "^p42di 130" | awk '{print $3}')
    elapsed=$(cat $html_file | grep "^p42di 140" | awk '{print $3}')
    status=$(cat $html_file | grep "^p42di 110" | awk '{print $3}')
    
    test_name=$(basename "$html_file" .html)

    cat <<EOF
    -------------------------------------------------------------
      html_file: $PWD/$html_file
      test_name: $test_name
       git_date: $git_date
       git_time: $git_time
    gittimezone: $gittimezone
       git_hash: $git_hash
        elapsed: $elapsed
         status: $status
EOF
  
    oldifs="$IFS"
    IFS=$'\n'
    for caseline in $(cat "$html_file" | grep "p42dc 10"); do
        my_status=$(echo "$caseline" | awk -F' ' '{print $2}')
        my_name=$(echo "$caseline" | awk -F' ' '{print $3}')
        cat <<EOF
             my_status: $my_status
               my_name: $my_name
EOF
    done
    IFS="$oldifs"
}

function old_email_stuff()
{
    if [ "$git_date" != "$today" -a "$git_date" != "$YESTERDAY" ]; then
        printVerbose "Git date for '$test_name' is '$git_date', not recent."
        rm -f $html_file
        return 0
    fi

    if [ "$status" == "SUCCESS" ]; then
        let N_TESTS_PASSED+=1
    elif [ "$status" == "FAILURE" ]; then
        let N_TESTS_FAILED+=1
    fi

    printf "%32s "  "$test_name"   | tee --append $REPORT_FILE
    printf "%-10s " "$status"      | tee --append $REPORT_FILE
    printf "%10s "  "$git_date"    | tee --append $REPORT_FILE
    printf "%8s "   "$git_time"    | tee --append $REPORT_FILE
    printf "%5s "   "$gittimezone" | tee --append $REPORT_FILE
    printf "%8s "   "$elapsed"     | tee --append $REPORT_FILE
    printf "%12s "  "$git_hash"    | tee --append $REPORT_FILE

    if [ "$git_date" != "$today" -a "$git_date" != "$YESTERDAY" ]; then
        rm -f $html_file
        printf "OLD\n" | tee --append $REPORT_FILE
        return 0
    fi

    printf "\n" | tee --append $REPORT_FILE
}

function test_names()
{
    local test_dir

    if [ -n "$OPTION_TESTS" ]; then
        echo $OPTION_TESTS
        return 0
    fi

    test_dir="/home/pipas/Desktop/stuff/work/s9s-tools/tests"

    if [ -d "$test_dir" ]; then
        for script_file in $test_dir/ft_*.sh; do
            if [ ! -f "$script_file" ]; then
                continue
            fi

            echo $(basename $script_file)
        done

        return 0
    fi

    cat <<EOF
ft_access.sh 
ft_acl.sh 
ft_adminuser.sh 
ft_cat.sh 
ft_cdt.sh 
ft_galerasimple.sh
ft_jobs.sh
ft_maintenance.sh
ft_postgresqlsimple_11.sh
ft_postgresqlsimple.sh
ft_postgresql_9.4.sh
ft_postgresql_9.5.sh
ft_postgresql_9.6.sh
ft_postgresql_10.sh
ft_postgresql_11.sh
ft_postgresqlbackup.sh
ft_postgresqlfailover.sh
ft_reports.sh
ft_tree.sh
ft_user.sh 
ft_scripts.sh
ft_galera.sh
ft_galera_mariadb_10.4.sh
ft_cmonhabasic
ft_cmonhabasic1
ft_cmonhabasic3
ft_cmonhadaemon
ft_cmonhadaemon3
ft_cmonhagalera
ft_cmonhalxc1
ft_cmonhadaemon2
ft_cmonhadaemonbasic
ft_cmonhadaemonping	
ft_cmonhalxc
ft_cmonhalxc2
ft_cmonhalxc3
ft_cmonhalxc4	
ft_cmonhalxc5
ft_cmonhapostgres
ft_cmonhasimple
ft_haproxy.sh
ft_ldap.sh
ft_ldaperror.sh
ft_ldapgroups.sh
ft_ldapnogroups.sh
ft_ndb.sh
ft_replication_aws.sh
ft_galerakill.sh
ft_galerassl.sh
ft_galera_lxc.sh
ft_installserver.sh
ft_galera_c2c.sh
ft_containers_lxc.sh
ft_errors.sh
ft_metatype.sh
ft_controllersave.sh
ft_controllersavemulti.sh
ft_controllersavelocal.sh
ft_controllersavelocalmulti.sh
ft_mongodb_3.4.sh
ft_mongodb.sh
ft_multiserver.sh
ft_postgresqlslave.sh
ft_postgresqlstop.sh
ft_mysqlreplicationconfig.sh
ft_groupreplication.sh
ft_cluster_error.sh
ft_proxysql_connect.sh
ft_registergalera.sh
EOF
}

function plural_test()
{
    local n="$1"

    if [ "$n" == "0" ]; then
        echo "no tests"
    elif [ "$n" == "1" ]; then
        echo "one test"
    else
        echo "$n tests"
    fi
}

function email_body()
{
    local subject
    local ref_url="https://80.98.196.73/ft_install/"

    if [ "$N_TESTS_FAILED" == "0" ]; then
        subject="Daily s9s test results (all $N_TESTS_PASSED green)."
    elif [ "$N_TESTS_FAILED" == "1" ]; then
        subject="Daily s9s test results (1 failure)."
    else
        subject="Daily s9s test results ($N_TESTS_FAILED failures)."
    fi

    echo -en "From: pipas@borgcollective.eu\r\n"
    echo -en "Subject: ${subject}.\r\n"
    echo -en "Mime-Version: 1.0\r\n"
    echo -en "Subject: Subject_heading\r\n"
    echo -en "Content-Type: multipart/mixed; boundary=\"-\"\r\n"
    echo -en "\r\n"
    
    echo -en "---\r\n"
    echo -en "Content-Type: text/html; charset=utf-8\r\n"
    echo -en "\r\n"
    echo "<html>"
    echo "  <body>"
    echo "    <h1>Daily s9s test results</h1>"
    echo "    <p>Please find the attached test results of the s9s functional "
    echo "tests that are selected for daily testing. Only tests that contain "
    echo "git commit date in the last day or today are presented here.</p>"
    echo "    <p>These test scrips can be found in the s9s-tools source "
    echo "under the tests/ subdirectory.</p>"
    echo "    <p>You may want to check the up to date test reports at "
    echo "      <a href=\"$ref_url\">$ref_url</a> (login name and password "
    echo "      required).</p>"
    echo "    <pre>"
    cat $REPORT_FILE
    echo "    </pre>"
    echo "  </body>"
    echo "</html>"
    echo ""

    echo -en "---\r\n"
    echo -en "Content-Type: application/octet-stream; name=\"$gzfile\"\r\n"
    echo -en "Content-Transfer-Encoding: base64\r\n"
    echo -en "Content-Disposition: inline; filename=\"$gzfile\"\r\n"
    echo -en "\r\n"
    
    uuencode --base64 $gzfile /dev/stdout
    echo -en "\r\n"
    echo -en "---\r\n"
}

function send_mail_to_list()
{
    local recipient

    if [ -n "$OPTION_NO_MAIL" ]; then
        return 0
    fi

    for recipient in $(cat "$MAIL_LIST_FILE"); do
        printVerbose "Sending email to ${recipient}..."
        email_body | ssmtp "$recipient"
        let N_MAILS_SENT+=1
    done
}

#
# Checking the command line option.
#
pip-say "It is $(date +%R)."
pip-say "Preparing to download logs about tests."
if [ -z "$OPTION_MAIL_LIST" -a -z "$OPTION_NO_MAIL" ]; then
    printError "One of the --mail-list or --no-mail options is mandatory."
    pip-say "Command line option error found, aborting download program."
    exit 5
fi

if [ -n "$OPTION_MAIL_LIST" ]; then
    MAIL_LIST_FILE="$HOME/.pip/${OPTION_MAIL_LIST}.list"
    if [ ! -f "$MAIL_LIST_FILE" ]; then
        printError "File '$MAIL_LIST_FILE' was not found..."
        printError "File not found for $OPTION_MAIL_LIST, aborting.."
        exit 5
    fi
fi

if [ ! -d "$HOME/tests" ]; then
    mkdir $HOME/tests
fi

cd "$HOME/tests"
if [ "$PWD" != "$HOME/tests" ]; then
    pip-say "Downloading test results failed, target directory was not found."
    printError "Could not create '$HOME/tests'..."
    exit 1
fi

#
#
#
pip-say "Downloading daily test results."

export WWW_PASSWORD="$PASSWORD"
export WWW_USER="pipas"

if [ -z "$WWW_PASSWORD" ]; then
    pip-say "The 'PASSWORD' environment variable should be present."
    exit 1
fi

if [ -z "$WWW_USER" ]; then
    pip-say "The 'WWW_USER' environment variable should be present."
    exit 1
fi


mytests=$(test_names)

[ -f "$REPORT_FILE" ] && rm -f $REPORT_FILE

echo "{code}"

print_header | tee --append $REPORT_FILE

NUMBER_OF_TEST_SCRIPTS=0
for testscript in $mytests; do
    #echo "1 testscript: $testscript"
    let NUMBER_OF_TEST_SCRIPTS+=1
done

for old_file in $OPTION_OUTPUT_DIR/*.xml; do
    if [ ! -f "$old_file" ]; then
        continue
    fi

    #printWarning "Removing $old_file..."
    rm -f $old_file
done

for testscript in $mytests; do
    HTML_FILE=$(download_html_file "$testscript")
    if [ -z "$HTML_FILE" ]; then
        continue
    fi

    if [ ! -f "$HTML_FILE" ]; then
        continue
    fi

    XML_FILE="/tmp/pip_download.xml"

    XML_FILE="$OPTION_OUTPUT_DIR/"
    XML_FILE+="$(basename $HTML_FILE .html)"
    XML_FILE+=".xml"

    printf "$HTML_FILE               \r"
    process_html_file_xml \
        --html-file $HTML_FILE >$XML_FILE

    if [ $? -ne 0 ]; then
        printWarning "Removing $XML_FILE..."
        rm -f "$XML_FILE"
    fi

    cp $HTML_FILE $OPTION_OUTPUT_DIR
    echo "I am trying to figure this out." >"$OPTION_OUTPUT_DIR/readme.txt"
done

print_footer | tee --append $REPORT_FILE
echo "{code}"

exit 0

if [ "$N_TESTS_PASSED" == "0" -a "$N_TESTS_FAILED" == "0" ]; then
    pip-say "Found no test results."
    exit 6
else
    pip-say "Download succeeded, $(plural_test $N_TESTS_PASSED) passed, \
        $(plural_test $N_TESTS_FAILED) failed."
fi

tar czf "${gzfile}" "$ymd"
send_mail_to_list

if [ "$N_MAILS_SENT" -eq 0 ]; then
    pip-say "Download program finished, no notification was sent."
elif [ "$N_MAILS_SENT" -eq 1 ]; then
    pip-say "Download program finished, one notification was sent."
else
    pip-say "Download program finished, $N_MAILS_SENT notifications were sent."
fi


