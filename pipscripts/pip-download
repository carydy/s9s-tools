#! /bin/bash
MYNAME=$(basename "$0")
MYDIR=$(dirname "$0")
MYDIR=$(readlink -m "$MYDIR")
VERSION="0.0.7"
VERBOSE=""
LOGFILE="$HOME/pip-cmon-test.log"
EXITCODE=0

COMMAND_LINE_OPTIONS="$0 $*"
OPTION_MAIL_LIST=""
OPTION_NO_MAIL=""
OPTION_TESTS=""


MAIL_LIST_FILE=""

REPORT_FILE=""

today=$(date "+%Y-%m-%d" 2>/dev/null)
YESTERDAY=$(date "+%Y-%m-%d" -d "yesterday" 2>/dev/null)

ymd=$(echo "$today" | tr '-' '_')
gzfile="${ymd}.tar.gz"

N_TESTS_PASSED=0
N_TESTS_FAILED=0
N_MAILS_SENT=0

REPORT_FILE="${ymd}.text"

source $MYDIR/utilityfunctions.sh

function printHelpAndExit()
{
cat <<EOF

Usage:
  $MYNAME [OPTION]... [TEST_NAME]...

  $MYNAME - Downloads test results from my server. :)

  -h, --help              Print this help and exit.
  -v, --version           Print version information and exit.
  --verbose               Print more messages.
  --log-file=FILE         Store all the messages in the given file too.
  --mail-list=NAME        The name of the mail list.
  --no-mail               Do not send mail.
 
EXAMPLES:
  PASSWORD="SSSSSSS" pip-download --verbose --no-mail
  PASSWORD="SSSSSSS" pip-download --verbose --mail-list=myself

EOF

  exit 0
}

ARGS=$(\
    getopt \
        -o hvj: \
        -l "help,verbose,version,log-file:,
no-mail,mail-list:" \
        -- "$@")

if [ $? -ne 0 ]; then
    exit 6
fi

eval set -- "$ARGS"
while true; do
    case "$1" in
        -h|--help)
            shift
            printHelpAndExit
            ;;

        --verbose)
            shift
            VERBOSE="true"
            ;;

        -v|--version)
            shift
            printVersionAndExit
            ;;

        --log-file)
            shift
            LOGFILE=$(readlink -m "$1")
            shift
            ;;

        --mail-list)
            OPTION_MAIL_LIST="$2"
            shift 2
            ;;

        --no-mail)
            OPTION_NO_MAIL="true"
            shift
            ;;

        --)
            shift
            break
            ;;

        *)
            printError "Unhandled option $1"
            exit 1
            ;;
    esac
done

OPTION_TESTS="$*"


function print_header()
{
    cat <<EOF
                       TEST_NAME STATUS     COMMITTED                 ELAPSED  GIT HASH
=======================================================================================================================
EOF
}

function print_footer()
{
    cat <<EOF
=======================================================================================================================

Summary:
     passed: $N_TESTS_PASSED test(s)
     failed: $N_TESTS_FAILED test(s)

EOF
}

function download_html_file()
{
    local url
    local server="www"

    [ ! -d "$ymd" ] && mkdir "$ymd"

    test_name="$1"
    html_file="$ymd/$(basename $test_name .sh).html"

    url="https://$server/ft_install/"
    url+="?page=test&test_name=$test_name&full_screen=true"

    #
    # We download the test results from the web, this way the reports are nicely
    # formatted for easy use.
    #
    wget \
        --user=$WWW_USER \
        --password="$WWW_PASSWORD" \
        --no-check-certificate \
        "$url" \
        --output-document=$html_file 2>/dev/null

    if [ $? -ne 0 ]; then 
        return 1
    fi

    echo "$html_file"
    #ls -lha $html_file
}

function process_html_file_xml()
{
    local test_name
    local html_file
    local git_date
    local git_time
    local git_timezone
    local elapsed
    local html_file

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file=$2
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    if [ -z "$html_file" ]; then
        printError "process_html_file: No HTML file."
        return 1
    elif [ ! -f "$html_file" ]; then
        printError "process_html_file: File '$html_file' was not found."
        return 1
    fi

    #
    # The downloaded file has these fields embedded in a HTML comment so that we
    # can have everything in one single HTML file.
    #
    git_date=$(cat $html_file | grep "^p42di 120" | awk '{print $3}')
    git_time=$(cat $html_file | grep "^p42di 121" | awk '{print $3}')
    gittimezone=$(cat $html_file | grep "^p42di 122" | awk '{print $3}')
    git_hash=$(cat $html_file | grep "^p42di 130" | awk '{print $3}')
    elapsed=$(cat $html_file | grep "^p42di 140" | awk '{print $3}')
    status=$(cat $html_file | grep "^p42di 110" | awk '{print $3}')
    
    test_name=$(basename "$html_file" .html)

    n_failures=$(cat $html_file | grep 'p42dc 102' | wc -l)
    n_cases=$(cat $html_file | grep 'p42dc 10' | wc -l)

    echo ""
    echo ""
    cat <<EOF
<?xml version="1.0" ?>
<!-- Creted by pip-download $VERSION. -->
<testsuite failures="$n_failures" tests="$n_cases">
EOF

#    -------------------------------------------------------------
#      html_file: $PWD/$html_file
#      test_name: $test_name
#       git_date: $git_date
#       git_time: $git_time
#    gittimezone: $gittimezone
#       git_hash: $git_hash
#        elapsed: $elapsed
#         status: $status

  
    oldifs="$IFS"
    IFS=$'\n'
    for caseline in $(cat "$html_file" | grep "p42dc 10"); do
        my_status=$(echo "$caseline" | awk -F' ' '{print $2}')
        my_name=$(echo "$caseline" | awk -F' ' '{print $3}')
        case "$my_status" in 
            101)
                my_status="skipped"
                ;;

            102)
                my_status="failure"
                ;;

            103)
                my_status="success"
                ;;

            *)
                my_status="invalid"
                ;;
        esac

        cat <<EOF
  <testcase classname="$test_name" name="$my_name" status="$my_status">
  </testcase>
EOF
    done
    IFS="$oldifs"

    cat <<EOF
</testsuite>
EOF

    return 0
    if [ "$git_date" != "$today" -a "$git_date" != "$YESTERDAY" ]; then
        printVerbose "Git date for '$test_name' is '$git_date', not recent."
        rm -f $html_file
        return 0
    fi

    if [ "$status" == "SUCCESS" ]; then
        let N_TESTS_PASSED+=1
    elif [ "$status" == "FAILURE" ]; then
        let N_TESTS_FAILED+=1
    fi

    printf "%32s "  "$test_name"   | tee --append $REPORT_FILE
    printf "%-10s " "$status"      | tee --append $REPORT_FILE
    printf "%10s "  "$git_date"    | tee --append $REPORT_FILE
    printf "%8s "   "$git_time"    | tee --append $REPORT_FILE
    printf "%5s "   "$gittimezone" | tee --append $REPORT_FILE
    printf "%8s "   "$elapsed"     | tee --append $REPORT_FILE
    printf "%12s "  "$git_hash"    | tee --append $REPORT_FILE

    if [ "$git_date" != "$today" -a "$git_date" != "$YESTERDAY" ]; then
        rm -f $html_file
        printf "OLD\n" | tee --append $REPORT_FILE
        return 0
    fi

    printf "\n" | tee --append $REPORT_FILE
}

function process_html_file()
{
    local test_name
    local html_file
    local git_date
    local git_time
    local git_timezone
    local elapsed
    local html_file

    while [ -n "$1" ]; do
        case "$1" in 
            --html-file)
                html_file=$2
                shift 2
                ;;

            *)
                printError "process_html_file: Invalid option '$1'."
                return 1
                ;;
        esac
    done

    if [ -z "$html_file" ]; then
        printError "process_html_file: No HTML file."
        return 1
    elif [ ! -f "$html_file" ]; then
        printError "process_html_file: File '$html_file' was not found."
        return 1
    fi

    #
    # The downloaded file has these fields embedded in a HTML comment so that we
    # can have everything in one single HTML file.
    #
    git_date=$(cat $html_file | grep "^p42di 120" | awk '{print $3}')
    git_time=$(cat $html_file | grep "^p42di 121" | awk '{print $3}')
    gittimezone=$(cat $html_file | grep "^p42di 122" | awk '{print $3}')
    git_hash=$(cat $html_file | grep "^p42di 130" | awk '{print $3}')
    elapsed=$(cat $html_file | grep "^p42di 140" | awk '{print $3}')
    status=$(cat $html_file | grep "^p42di 110" | awk '{print $3}')
    
    test_name=$(basename "$html_file" .html)

    cat <<EOF
    -------------------------------------------------------------
      html_file: $PWD/$html_file
      test_name: $test_name
       git_date: $git_date
       git_time: $git_time
    gittimezone: $gittimezone
       git_hash: $git_hash
        elapsed: $elapsed
         status: $status
EOF
  
    oldifs="$IFS"
    IFS=$'\n'
    for caseline in $(cat "$html_file" | grep "p42dc 10"); do
        my_status=$(echo "$caseline" | awk -F' ' '{print $2}')
        my_name=$(echo "$caseline" | awk -F' ' '{print $3}')
        cat <<EOF
             my_status: $my_status
               my_name: $my_name
EOF
    done
    IFS="$oldifs"

    return 0
    if [ "$git_date" != "$today" -a "$git_date" != "$YESTERDAY" ]; then
        printVerbose "Git date for '$test_name' is '$git_date', not recent."
        rm -f $html_file
        return 0
    fi

    if [ "$status" == "SUCCESS" ]; then
        let N_TESTS_PASSED+=1
    elif [ "$status" == "FAILURE" ]; then
        let N_TESTS_FAILED+=1
    fi

    printf "%32s "  "$test_name"   | tee --append $REPORT_FILE
    printf "%-10s " "$status"      | tee --append $REPORT_FILE
    printf "%10s "  "$git_date"    | tee --append $REPORT_FILE
    printf "%8s "   "$git_time"    | tee --append $REPORT_FILE
    printf "%5s "   "$gittimezone" | tee --append $REPORT_FILE
    printf "%8s "   "$elapsed"     | tee --append $REPORT_FILE
    printf "%12s "  "$git_hash"    | tee --append $REPORT_FILE

    if [ "$git_date" != "$today" -a "$git_date" != "$YESTERDAY" ]; then
        rm -f $html_file
        printf "OLD\n" | tee --append $REPORT_FILE
        return 0
    fi

    printf "\n" | tee --append $REPORT_FILE
}

function test_names()
{
    if [ -n "$OPTION_TESTS" ]; then
        echo $OPTION_TESTS
        return 0
    fi

    cat <<EOF
ft_access.sh 
ft_acl.sh 
ft_adminuser.sh 
ft_cat.sh 
ft_cdt.sh 
ft_galerasimple.sh
ft_jobs.sh
ft_maintenance.sh
ft_postgresqlsimple_11.sh
ft_postgresqlsimple.sh
ft_postgresql_9.4.sh
ft_postgresql_9.5.sh
ft_postgresql_9.6.sh
ft_postgresql_10.sh
ft_postgresql_11.sh
ft_postgresqlbackup.sh
ft_postgresqlfailover.sh
ft_reports.sh
ft_tree.sh
ft_user.sh 
ft_scripts.sh
ft_galera.sh
ft_galera_mariadb_10.4.sh
ft_cmonhabasic
ft_cmonhabasic1
ft_cmonhabasic3
ft_cmonhadaemon
ft_cmonhadaemon3
ft_cmonhagalera
ft_cmonhalxc1
ft_cmonhadaemon2
ft_cmonhadaemonbasic
ft_cmonhadaemonping	
ft_cmonhalxc
ft_cmonhalxc2
ft_cmonhalxc3
ft_cmonhalxc4	
ft_cmonhalxc5
ft_cmonhapostgres
ft_cmonhasimple
ft_haproxy.sh
ft_ldap.sh
ft_ldaperror.sh
ft_ldapgroups.sh
ft_ldapnogroups.sh
ft_ndb.sh
ft_replication_aws.sh
ft_galerakill.sh
ft_galerassl.sh
ft_galera_lxc.sh
ft_installserver.sh
ft_galera_c2c.sh
ft_containers_lxc.sh
ft_errors.sh
ft_metatype.sh
ft_controllersave.sh
ft_controllersavemulti.sh
ft_controllersavelocal.sh
ft_controllersavelocalmulti.sh
ft_mongodb_3.4.sh
ft_mongodb.sh
ft_multiserver.sh
ft_postgresqlslave.sh
ft_postgresqlstop.sh
ft_mysqlreplicationconfig.sh
ft_groupreplication.sh
ft_cluster_error.sh
ft_proxysql_connect.sh
ft_registergalera.sh
EOF
}

function plural_test()
{
    local n="$1"

    if [ "$n" == "0" ]; then
        echo "no tests"
    elif [ "$n" == "1" ]; then
        echo "one test"
    else
        echo "$n tests"
    fi
}

function email_body()
{
    local subject
    local ref_url="https://80.98.196.73/ft_install/"

    if [ "$N_TESTS_FAILED" == "0" ]; then
        subject="Daily s9s test results (all $N_TESTS_PASSED green)."
    elif [ "$N_TESTS_FAILED" == "1" ]; then
        subject="Daily s9s test results (1 failure)."
    else
        subject="Daily s9s test results ($N_TESTS_FAILED failures)."
    fi

    echo -en "From: pipas@borgcollective.eu\r\n"
    echo -en "Subject: ${subject}.\r\n"
    echo -en "Mime-Version: 1.0\r\n"
    echo -en "Subject: Subject_heading\r\n"
    echo -en "Content-Type: multipart/mixed; boundary=\"-\"\r\n"
    echo -en "\r\n"
    
    echo -en "---\r\n"
    echo -en "Content-Type: text/html; charset=utf-8\r\n"
    echo -en "\r\n"
    echo "<html>"
    echo "  <body>"
    echo "    <h1>Daily s9s test results</h1>"
    echo "    <p>Please find the attached test results of the s9s functional "
    echo "tests that are selected for daily testing. Only tests that contain "
    echo "git commit date in the last day or today are presented here.</p>"
    echo "    <p>These test scrips can be found in the s9s-tools source "
    echo "under the tests/ subdirectory.</p>"
    echo "    <p>You may want to check the up to date test reports at "
    echo "      <a href=\"$ref_url\">$ref_url</a> (login name and password "
    echo "      required).</p>"
    echo "    <pre>"
    cat $REPORT_FILE
    echo "    </pre>"
    echo "  </body>"
    echo "</html>"
    echo ""

    echo -en "---\r\n"
    echo -en "Content-Type: application/octet-stream; name=\"$gzfile\"\r\n"
    echo -en "Content-Transfer-Encoding: base64\r\n"
    echo -en "Content-Disposition: inline; filename=\"$gzfile\"\r\n"
    echo -en "\r\n"
    
    uuencode --base64 $gzfile /dev/stdout
    echo -en "\r\n"
    echo -en "---\r\n"
}

function send_mail_to_list()
{
    local recipient

    if [ -n "$OPTION_NO_MAIL" ]; then
        return 0
    fi

    for recipient in $(cat "$MAIL_LIST_FILE"); do
        printVerbose "Sending email to ${recipient}..."
        email_body | ssmtp "$recipient"
        let N_MAILS_SENT+=1
    done
}

#
# Checking the command line option.
#
pip-say "It is $(date +%R)."
pip-say "Preparing to download logs about tests."
if [ -z "$OPTION_MAIL_LIST" -a -z "$OPTION_NO_MAIL" ]; then
    printError "One of the --mail-list or --no-mail options is mandatory."
    pip-say "Command line option error found, aborting download program."
    exit 5
fi

if [ -n "$OPTION_MAIL_LIST" ]; then
    MAIL_LIST_FILE="$HOME/.pip/${OPTION_MAIL_LIST}.list"
    if [ ! -f "$MAIL_LIST_FILE" ]; then
        printError "File '$MAIL_LIST_FILE' was not found..."
        printError "File not found for $OPTION_MAIL_LIST, aborting.."
        exit 5
    fi
fi

if [ ! -d "$HOME/tests" ]; then
    mkdir $HOME/tests
fi

cd "$HOME/tests"
if [ "$PWD" != "$HOME/tests" ]; then
    pip-say "Downloading test results failed, target directory was not found."
    printError "Could not create '$HOME/tests'..."
    exit 1
fi

#
#
#
pip-say "Downloading daily test results."

export WWW_PASSWORD="$PASSWORD"
export WWW_USER="pipas"

if [ -z "$WWW_PASSWORD" ]; then
    pip-say "The 'PASSWORD' environment variable should be present."
    exit 1
fi

if [ -z "$WWW_USER" ]; then
    pip-say "The 'WWW_USER' environment variable should be present."
    exit 1
fi


tests=$(test_names)

[ -f "$REPORT_FILE" ] && rm -f $REPORT_FILE

echo "{code}"

print_header | tee --append $REPORT_FILE

for testname in $tests; do
    HTML_FILE=$(download_html_file "$testname")
    process_html_file_xml \
        --html-file $HTML_FILE
done

print_footer | tee --append $REPORT_FILE
echo "{code}"

if [ "$N_TESTS_PASSED" == "0" -a "$N_TESTS_FAILED" == "0" ]; then
    pip-say "Found no test results."
    exit 6
else
    pip-say "Download succeeded, $(plural_test $N_TESTS_PASSED) passed, \
        $(plural_test $N_TESTS_FAILED) failed."
fi

tar czf "${gzfile}" "$ymd"
send_mail_to_list

if [ "$N_MAILS_SENT" -eq 0 ]; then
    pip-say "Download program finished, no notification was sent."
elif [ "$N_MAILS_SENT" -eq 1 ]; then
    pip-say "Download program finished, one notification was sent."
else
    pip-say "Download program finished, $N_MAILS_SENT notifications were sent."
fi


